.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ConfigFile 3"
.TH ConfigFile 3 "2000-05-02" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Unix::ConfigFile \- Perl interface to various Unix configuration files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Unix::ConfigFile;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Unix::ConfigFile module provides a base class from which the other
Unix::*File modules are derived.  It provides some basic facilities like file
opening, locking, and closing.  You do not need to use this module directly
unless you are developing a derived module for an unsupported configuration
file.  However, some of the methods documented here are intended for public
use by users of Unix::ConfigFile submodules, so you may find this
documentation useful even if you are not developing your own module.
.PP
The ConfigFile object also provides a sequencing \s-1API\s0 for modules that wish to
preserve the order of the configuration file they read and write.  The
sequencer maintains a list of arbitrary data that a submodule may append,
insert, and delete from.  Use of the sequencer is completely optional.
.PP
A module that subclasses from Unix::ConfigFile must, at a minimum, provide two
methods, called \*(L"read\*(R" and \*(L"write\*(R".  Both methods will receive a filehandle as
a parameter (besides the regular object parameter).  The read method is called
after the file is opened.  It is expected to read in the configuration file
and initialize the subclass-specific data structures associated with the
object.  The write method is called when an object is committed and is
expected to write out the new configuration to the supplied filehandle.
.SH "USER METHODS"
.IX Header "USER METHODS"
.Sh "commit( [%OPTIONS] )"
.IX Subsection "commit( [%OPTIONS] )"
This writes any changes you have made to the object back to disk.  If you do
not call commit, none of your changes will be reflected in the file you are
modifying.  Commit may not be called on files opened in read-only mode.  There
are some optional parameters that may be provided; these are passed in the form
of key => value pairs.  The \*(L"backup\*(R" option allows you to specify a file
extension that will be used to save a backup of the original file.  The
\&\*(L"writeopts\*(R" option passes module-specific options through to the write method.
It will accept any scalar for its value; typically this will be a list or hash
reference.  Commit returns 1 on success and 0 on failure.
.Sh "encpass( \s-1PASSWORD\s0 )"
.IX Subsection "encpass( PASSWORD )"
This method encrypts the supplied plaintext password using a random salt and
returns the encrypted password.  Note that this method does not actually make
any use of the object that it is invoked on, and could be called as a class
method.
.Sh "new( \s-1FILENAME\s0 [,%OPTIONS] )"
.IX Subsection "new( FILENAME [,%OPTIONS] )"
The new method constructs a new ConfigFile (or subclass) object using the
specified \s-1FILENAME\s0.  There are several optional parameters that may be
specified.  Options must be passed as keyed pairs in the form of option =>
value.  Valid options are \*(L"locking\*(R", \*(L"lockfile\*(R", \*(L"mode\*(R", and \*(L"readopts\*(R".  The
locking option determines what style of file locking is used; available styles
are \*(L"dotlock\*(R", \*(L"flock\*(R", and \*(L"none\*(R".  The default locking style is \*(L"dotlock\*(R".
The \*(L"none\*(R" locking style causes no locking to be done, and all lock and unlock
requests will return success.  The lockfile option can be used to specify the
lock filename used with dotlocking.  The default is \*(L"\s-1FILENAME\s0.lock\*(R", where
\&\s-1FILENAME\s0 is the name of the file being opened.  The mode option allows the
file open mode to be specified.  The default mode is \*(L"r+\*(R" (read/write), but
\&\*(L"r\*(R" and \*(L"w\*(R" are accepted as well.  Finally, the readopts option allows
module-specific options to be passed through to the read method.  It will
accept any scalar for its value; typically this will be a list or hash
reference.
.SH "DEVELOPER METHODS"
.IX Header "DEVELOPER METHODS"
.ie n .Sh "joinwrap( \s-1LENGTH\s0, \s-1HEAD\s0, \s-1INDENT\s0, \s-1DELIM\s0, \s-1TAIL\s0, @LIST )"
.el .Sh "joinwrap( \s-1LENGTH\s0, \s-1HEAD\s0, \s-1INDENT\s0, \s-1DELIM\s0, \s-1TAIL\s0, \f(CW@LIST\fP )"
.IX Subsection "joinwrap( LENGTH, HEAD, INDENT, DELIM, TAIL, @LIST )"
This is a utility function that may be called as an object or class method.
As the name suggests, this method is basically a version of the join function
that incorporates line wrapping.  The specified list will be joined together,
with each list element separated by the specified delimiter.  The first line
of output will be prefixed with the \s-1HEAD\s0 parameter.  If a line exceeds the
length parameter, output is wrapped to the next line and the \s-1INDENT\s0 parameter
is used to prefix the line.  In addition, the \s-1TAIL\s0 parameter will be added to
the end of every line generated except the final one.  There is one case where
the resulting string can exceed the specified line length \- if a single list
element, plus \s-1HEAD\s0 or \s-1INDENT\s0, exceeds that length.  One final feature is that
if the \s-1HEAD\s0 or \s-1INDENT\s0 parameters contain the text '%n', it will be replaced
with the current line number, beginning at 0.
.Sh "sequence( )"
.IX Subsection "sequence( )"
Returns the current sequence list associated with the object.  This is a list
of arbitrary data maintained by a ConfigFile submodule.  The ConfigFile module
does not care what is contained in the list.
.ie n .Sh "seq_append( @DATA )"
.el .Sh "seq_append( \f(CW@DATA\fP )"
.IX Subsection "seq_append( @DATA )"
Appends that specified data to the end of the sequence list.
.ie n .Sh "seq_insert( \s-1KEY\s0, @DATA )"
.el .Sh "seq_insert( \s-1KEY\s0, \f(CW@DATA\fP )"
.IX Subsection "seq_insert( KEY, @DATA )"
Inserts the data into the sequence list before the data that matches the
specified key.
.Sh "seq_remove( \s-1KEY\s0 )"
.IX Subsection "seq_remove( KEY )"
Removes the data from the sequence list that matches the specified key.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Snodgrass, ssnodgra@fore.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Unix::AliasFile, Unix::AutomountFile, Unix::GroupFile, Unix::PasswdFile
