.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PasswdFile 3"
.TH PasswdFile 3 "2000-05-02" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Unix::PasswdFile \- Perl interface to /etc/passwd format files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Unix::PasswdFile;
.Ve
.PP
.Vb 10
\&  $pw = new Unix::PasswdFile "/etc/passwd";
\&  $pw->user("joeblow", $pw->encpass("secret"), $pw->maxuid + 1, 10,
\&            "Joe Blow", "/export/home/joeblow", "/bin/ksh");
\&  $pw->delete("deadguy");
\&  $pw->passwd("johndoe", $pw->encpass("newpass"));
\&  foreach $user ($pw->users) {
\&      print "Username: $user, Full Name: ", $pw->gecos($user), "\en";
\&  }
\&  $pw->commit();
\&  undef $pw;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Unix::PasswdFile module provides an abstract interface to /etc/passwd
format files.  It automatically handles file locking, getting colons in the
right places, and all the other niggling details.
.SH "METHODS"
.IX Header "METHODS"
.Sh "commit( [\s-1BACKUPEXT\s0] )"
.IX Subsection "commit( [BACKUPEXT] )"
See the Unix::ConfigFile documentation for a description of this method.
.Sh "delete( \s-1USERNAME\s0 )"
.IX Subsection "delete( USERNAME )"
This method will delete the named user.  It has no effect if the supplied user
does not exist.
.Sh "encpass( \s-1PASSWORD\s0 )"
.IX Subsection "encpass( PASSWORD )"
See the Unix::ConfigFile documentation for a description of this method.
.Sh "gecos( \s-1USERNAME\s0 [,GECOS] )"
.IX Subsection "gecos( USERNAME [,GECOS] )"
Read or modify a user's \s-1GECOS\s0 string (typically their full name).  Returns
the \s-1GECOS\s0 string in either case.
.Sh "gid( \s-1USERNAME\s0 [,GID] )"
.IX Subsection "gid( USERNAME [,GID] )"
Read or modify a user's \s-1GID\s0.  Returns the \s-1GID\s0 in either case.
.Sh "home( \s-1USERNAME\s0 [,HOMEDIR] )"
.IX Subsection "home( USERNAME [,HOMEDIR] )"
Read or modify a user's home directory.  Returns the home directory in either
case.
.Sh "maxuid( [\s-1IGNORE\s0] )"
.IX Subsection "maxuid( [IGNORE] )"
This method returns the maximum \s-1UID\s0 in use by all users.  If you pass in the
optional \s-1IGNORE\s0 parameter, it will ignore all UIDs greater or equal to \s-1IGNORE\s0
when doing this calculation.  This is useful for excluding accounts like
nobody.
.Sh "new( \s-1FILENAME\s0 [,OPTIONS] )"
.IX Subsection "new( FILENAME [,OPTIONS] )"
See the Unix::ConfigFile documentation for a description of this method.
.Sh "passwd( \s-1USERNAME\s0 [,PASSWD] )"
.IX Subsection "passwd( USERNAME [,PASSWD] )"
Read or modify a user's password.  Returns the encrypted password in either
case.  If you have a plaintext password, use the encpass method to encrypt it
before passing it to this method.
.Sh "rename( \s-1OLDNAME\s0, \s-1NEWNAME\s0 )"
.IX Subsection "rename( OLDNAME, NEWNAME )"
This method changes the username for a user.  If \s-1NEWNAME\s0 corresponds to an
existing user, that user will be overwritten.  It returns 0 on failure and 1
on success.
.Sh "shell( \s-1USERNAME\s0 [,SHELL] )"
.IX Subsection "shell( USERNAME [,SHELL] )"
Read or modify a user's shell.  Returns the shell in either case.
.Sh "uid( \s-1USERNAME\s0 [,UID] )"
.IX Subsection "uid( USERNAME [,UID] )"
Read or modify a user's \s-1UID\s0.  Returns the \s-1UID\s0 in either case.
.Sh "user( \s-1USERNAME\s0 [,PASSWD, \s-1UID\s0, \s-1GID\s0, \s-1GECOS\s0, \s-1HOMEDIR\s0, \s-1SHELL\s0] )"
.IX Subsection "user( USERNAME [,PASSWD, UID, GID, GECOS, HOMEDIR, SHELL] )"
This method can add, modify, or return information about a user.  Supplied
with a single username parameter, it will return a six element list consisting
of (\s-1PASSWORD\s0, \s-1UID\s0, \s-1GID\s0, \s-1GECOS\s0, \s-1HOMEDIR\s0, \s-1SHELL\s0), or undef if no such user
exists.  If you supply all seven parameters, the named user will be created
or modified if it already exists.  The six element list is also returned to
you in this case.
.Sh "users( [\s-1SORTBY\s0] )"
.IX Subsection "users( [SORTBY] )"
This method returns a list of all existing usernames.  By default the list
will be sorted in order of the UIDs of the users.  You may also supply \*(L"name\*(R"
as a parameter to the method to get the list sorted by username.  In scalar
context, this method returns the total number of users.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Snodgrass, ssnodgra@fore.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Unix::AliasFile, Unix::AutomountFile, Unix::ConfigFile, Unix::GroupFile
